//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   01/Jul/2011  16:19:29 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203\PRG\SYS_V1.50\source\BIOS.c         /
//    Command line    =  D:\Design\DS203\PRG\SYS_V1.50\source\BIOS.c -lA     /
//                       D:\Design\DS203\PRG\SYS_V1.50\IAR_V4_Prpject\List\  /
//                       -o D:\Design\DS203\PRG\SYS_V1.50\IAR_V4_Prpject\Obj /
//                       \ -s9 --no_inline --cpu_mode thumb --endian little  /
//                       --cpu cortex-M3 --stack_align 4 -e --fpu None       /
//                       --dlib_config "C:\Program Files\IAR                 /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\LIB\dl7mptnnl8n.h" -I                /
//                       D:\Design\DS203\PRG\SYS_V1.50\IAR_V4_Prpject\..\..\ /
//                       FWLib\inc\ -I D:\Design\DS203\PRG\SYS_V1.50\IAR_V4_ /
//                       Prpject\..\..\USBLib\inc\ -I                        /
//                       D:\Design\DS203\PRG\SYS_V1.50\IAR_V4_Prpject\..\inc /
//                       lude\ -I "C:\Program Files\IAR Systems\Embedded     /
//                       Workbench 4.0 Evaluation\arm\INC\"                  /
//    List file       =  D:\Design\DS203\PRG\SYS_V1.50\IAR_V4_Prpject\List\B /
//                       IOS.s79                                             /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME BIOS

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

??DataTable1 EQU 0
        MULTWEAK ??Delayms??rT
        MULTWEAK ??__Chk_DFU??rT
        MULTWEAK ??__Chk_HDW??rT
        MULTWEAK ??u16ToDec5??rT
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC Clash
        PUBLIC DFU_Ver
        PUBLIC G_ATTR
        PUBLIC Get
        FUNCTION Get,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC HDW_Ver
        PUBLIC SendByte
        FUNCTION SendByte,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC Set
        FUNCTION Set,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC Set_Param
        FUNCTION Set_Param,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC T_ATTR
        PUBLIC VerStr
        PUBLIC X_ATTR
        PUBLIC Y_ATTR
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Delayms             SYMBOL "Delayms"
__Chk_DFU           SYMBOL "__Chk_DFU"
__Chk_HDW           SYMBOL "__Chk_HDW"
u16ToDec5           SYMBOL "u16ToDec5"
??Delayms??rT       SYMBOL "??rT", Delayms
??__Chk_DFU??rT     SYMBOL "??rT", __Chk_DFU
??__Chk_HDW??rT     SYMBOL "??rT", __Chk_HDW
??u16ToDec5??rT     SYMBOL "??rT", u16ToDec5

        EXTERN Delayms
        FUNCTION Delayms,0202H
        EXTERN SYS_Ver
        EXTERN __Chk_DFU
        FUNCTION __Chk_DFU,0202H
        EXTERN __Chk_HDW
        FUNCTION __Chk_HDW,0202H
        EXTERN u16ToDec5
        FUNCTION u16ToDec5,0202H

// D:\Design\DS203\PRG\SYS_V1.50\source\BIOS.c
//    1 /********************* (C) COPYRIGHT 2010 e-Design Co.,Ltd. ********************
//    2  File Name : BIOS.c  
//    3  Version   : DS203_SYS Ver 1.5x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include "Function.h"
//    6 #include "Config.h"
//    7 #include "Ident.h"
//    8 #include "BIOS.h"
//    9 #include "LCD.h"
//   10 #include "ASM.h"
//   11 
//   12 uc8  HDW_Ver[20] = "Hardware Ver 2.60 ";
//   13 uc8  DFU_Ver[5]  = "3.10";

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   14 u8   VerStr[8];
VerStr:
        DS8 8

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
//   15 u8   Clash = 0;
Clash:
        DS8 1

        RSEG DATA_C:CONST:SORT:NOROOT(2)
HDW_Ver:
        DATA
        DC8 "Hardware Ver 2.60 "
        DC8 0
DFU_Ver:
        DC8 "3.10"
        DC8 0, 0, 0
//   16 
//   17 const G_attr G_ATTR[1] =//LCD_X;LCD_Y;Yp_Max;Xp_Max;Tg_Num;Yv_Max;Xt_Max
G_ATTR:
        DC16 400, 240, 7, 21, 15, 200, 4096, 1
        DC8 1, 1, 17, 0
        DC16 0, 1024, 0, 1024
//   18                        {  400,   240,   8-1,    22-1,   15,     200,    4096,  
//   19                         //Co_Max;Ya_Num;Yd_Num;INSERT;KpA1;KpA2;KpB1;KpB2
//   20                            1,     1,     1,     17,    0,   1024,  0, 1024};
//   21 
//   22 const Y_attr Y_ATTR[9] ={//  STR     KA1    KA2    KB1    KB2     SCALE 
Y_ATTR:
        DC8 "50mV"
        DC8 0, 0, 0
        DC16 0, 1024, 0, 1024
        DC32 2000
        DC8 "0.1V"
        DC8 0, 0, 0
        DC16 0, 1024, 0, 1024
        DC32 4000
        DC8 "0.2V"
        DC8 0, 0, 0
        DC16 -2, 1024, -6, 1024
        DC32 8000
        DC8 "0.5V"
        DC8 0, 0, 0
        DC16 -1, 1024, -6, 1024
        DC32 20000
        DC8 " 1V "
        DC8 0, 0, 0
        DC16 0, 1024, -6, 1024
        DC32 40000
        DC8 " 2V "
        DC8 0, 0, 0
        DC16 -2, 1024, -6, 1024
        DC32 80000
        DC8 " 5V "
        DC8 0, 0, 0
        DC16 -1, 1024, -6, 1024
        DC32 200000
        DC8 "!10V!"
        DC8 0, 0
        DC16 0, 1024, -6, 1024
        DC32 400000
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//   23                          { "50mV",    0,   1024,    0,   1024,    2000},
//   24                          { "0.1V",    0,   1024,    0,   1024,    4000},
//   25                          { "0.2V",   -2,   1024,   -6,   1024,    8000},
//   26                          { "0.5V",   -1,   1024,   -6,   1024,   20000},
//   27                          { " 1V ",    0,   1024,   -6,   1024,   40000},
//   28                          { " 2V ",   -2,   1024,   -6,   1024,   80000},
//   29                          { " 5V ",   -1,   1024,   -6,   1024,  200000},
//   30                          { "!10V!",   0,   1024,   -6,   1024,  400000}};
//   31   
//   32 const X_attr X_ATTR[27] ={
X_ATTR:
        DC8 "! 1S !"
        DC8 0
        DC16 999, 2399, 1200, 1024
        DC32 33333333
        DC8 "500mS"
        DC8 0, 0
        DC16 999, 1199, 600, 1024
        DC32 16666667
        DC8 "200mS"
        DC8 0, 0
        DC16 999, 479, 240, 1024
        DC32 6666667
        DC8 "100mS"
        DC8 0, 0
        DC16 999, 239, 120, 1024
        DC32 3333333
        DC8 "!50mS!"
        DC8 0
        DC16 999, 119, 60, 1024
        DC32 1666667
        DC8 "!20mS!"
        DC8 0
        DC16 99, 479, 240, 1024
        DC32 666667
        DC8 "!10mS!"
        DC8 0
        DC16 99, 239, 120, 1024
        DC32 333333
        DC8 " 5mS "
        DC8 0, 0
        DC16 99, 119, 60, 1024
        DC32 166667
        DC8 " 2mS "
        DC8 0, 0
        DC16 9, 479, 240, 1024
        DC32 66667
        DC8 " 1mS "
        DC8 0, 0
        DC16 9, 239, 120, 1024
        DC32 33333
        DC8 "500uS"
        DC8 0, 0
        DC16 9, 119, 60, 1024
        DC32 16667
        DC8 "200uS"
        DC8 0, 0
        DC16 0, 479, 240, 1024
        DC32 6667
        DC8 "100uS"
        DC8 0, 0
        DC16 0, 239, 120, 1024
        DC32 3333
        DC8 "!50uS!"
        DC8 0
        DC16 0, 119, 60, 1024
        DC32 1667
        DC8 "!20uS!"
        DC8 0
        DC16 0, 47, 24, 1024
        DC32 667
        DC8 "!10uS!"
        DC8 0
        DC16 0, 23, 12, 1024
        DC32 333
        DC8 " 5uS "
        DC8 0, 0
        DC16 0, 11, 6, 1024
        DC32 167
        DC8 " 2uS "
        DC8 0, 0
        DC16 0, 4, 3, 983
        DC32 67
        DC8 " 1uS "
        DC8 0, 0
        DC16 0, 2, 2, 819
        DC32 33
        DC8 "0.5uS"
        DC8 0, 0
        DC16 0, 1, 1, 614
        DC32 17
        DC8 "0.2uS"
        DC8 0, 0
        DC16 0, 0, 1, 492
        DC32 7
        DC8 "0.1uS"
        DC8 0, 0
        DC16 0, 0, 1, 246
        DC32 3
        DC8 " 2uS+"
        DC8 0, 0
        DC16 0, 9, 3, 983
        DC32 67
        DC8 " 1uS+"
        DC8 0, 0
        DC16 0, 4, 2, 983
        DC32 33
        DC8 ".5uS+"
        DC8 0, 0
        DC16 0, 2, 1, 819
        DC32 17
        DC8 ".2uS+"
        DC8 0, 0
        DC16 0, 1, 1, 983
        DC32 7
        DC8 ".1uS+"
        DC8 0, 0
        DC16 0, 0, 1, 491
        DC32 3
//   33 //   STR      PSC      ARR      CCR    KP     SCALE
//   34   {"! 1S !", 1000-1,  2400-1,  1200,  1024, 33333333},
//   35   {"500mS",  1000-1,  1200-1,   600,  1024, 16666667}, 
//   36   {"200mS",  1000-1,   480-1,   240,  1024,  6666667}, 
//   37   {"100mS",  1000-1,   240-1,   120,  1024,  3333333},
//   38   {"!50mS!", 1000-1,   120-1,    60,  1024,  1666667}, 
//   39   {"!20mS!",  100-1,   480-1,   240,  1024,   666667}, 
//   40   {"!10mS!",  100-1,   240-1,   120,  1024,   333333}, 
//   41   {" 5mS ",   100-1,   120-1,    60,  1024,   166667},
//   42   {" 2mS ",    10-1,   480-1,   240,  1024,    66667}, 
//   43   {" 1mS ",    10-1,   240-1,   120,  1024,    33333},   
//   44   {"500uS",    10-1,   120-1,    60,  1024,    16667}, 
//   45   {"200uS",     1-1,   480-1,   240,  1024,     6667},
//   46   {"100uS",     1-1,   240-1,   120,  1024,     3333}, 
//   47   {"!50uS!",    1-1,   120-1,    60,  1024,     1667}, 
//   48   {"!20uS!",    1-1,    48-1,    24,  1024,      667},      
//   49   {"!10uS!",    1-1,    24-1,    12,  1024,      333},      
//   50   {" 5uS ",     1-1,    12-1,     6,  1024,      167},       
//   51   {" 2uS ",     1-1,     5-1,     3,   983,       67}, //1024*4.8/5 =983
//   52   {" 1uS ",     1-1,     3-1,     2,   819,       33}, //1024*2.4/3 =819 
//   53   {"0.5uS",     1-1,     2-1,     1,   614,       17}, //1024*1.2/2 =614
//   54   {"0.2uS",     1-1,     1-1,     1,   492,        7}, //1024*0.48  =492
//   55   {"0.1uS",     1-1,     1-1,     1,   246,        3}, //1024*0.24  =246 
//   56   {" 2uS+",     1-1,    10-1,     3,   983,       67}, //1024*9.6/10=983
//   57   {" 1uS+",     1-1,     5-1,     2,   983,       33}, //1024*4.8/5 =983
//   58   {".5uS+",     1-1,     3-1,     1,   819,       17}, //1024*2.4/3 =819
//   59   {".2uS+",     1-1,     2-1,     1,   983,        7}, //1024*0.96  =983
//   60   {".1uS+",     1-1,     1-1,     1,   491,        3}};//1024*0.48  =492
//   61 
//   62 const T_attr T_ATTR[32] ={
T_ATTR:
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 0, 0
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 1, 2
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 2, 4
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 3, 6
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 0, 1
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 1, 3
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 2, 5
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 3, 7
        DC8 ":!\\!"
        DC8 0, 0, 0, 0, 8
        DC8 ":!\\!"
        DC8 0, 0, 0, 1, 10
        DC8 ":!\\!"
        DC8 0, 0, 0, 2, 12
        DC8 ":!\\!"
        DC8 0, 0, 0, 3, 14
        DC8 ":!^!"
        DC8 0, 0, 0, 0, 9
        DC8 ":!^!"
        DC8 0, 0, 0, 1, 11
        DC8 ":!^!"
        DC8 0, 0, 0, 2, 13
        DC8 ":!^!"
        DC8 0, 0, 0, 3, 15
        DC8 "<TL"
        DC8 0, 0, 0, 0, 0, 16
        DC8 "<TL"
        DC8 0, 0, 0, 0, 1, 18
        DC8 "<TL"
        DC8 0, 0, 0, 0, 2, 20
        DC8 "<TL"
        DC8 0, 0, 0, 0, 3, 22
        DC8 ">TL"
        DC8 0, 0, 0, 0, 0, 17
        DC8 ">TL"
        DC8 0, 0, 0, 0, 1, 19
        DC8 ">TL"
        DC8 0, 0, 0, 0, 2, 21
        DC8 ">TL"
        DC8 0, 0, 0, 0, 3, 23
        DC8 "<TH"
        DC8 0, 0, 0, 0, 0, 24
        DC8 "<TH"
        DC8 0, 0, 0, 0, 1, 26
        DC8 "<TH"
        DC8 0, 0, 0, 0, 2, 28
        DC8 "<TH"
        DC8 0, 0, 0, 0, 3, 30
        DC8 ">TH"
        DC8 0, 0, 0, 0, 0, 25
        DC8 ">TH"
        DC8 0, 0, 0, 0, 1, 27
        DC8 ">TH"
        DC8 0, 0, 0, 0, 2, 29
        DC8 ">TH"
        DC8 0, 0, 0, 0, 3, 31
//   63 //  STR   CHx  CMD    STR   CHx  CMD    STR   CHx  CMD    STR   CHx  CMD
//   64   {"<Vt",  0, 0x00},{"<Vt",  1, 0x02},{"<Vt",  2, 0x04},{"<Vt",  3, 0x06},
//   65   {">Vt",  0, 0x01},{">Vt",  1, 0x03},{">Vt",  2, 0x05},{">Vt",  3, 0x07}, 
//   66   {":!\\!",0, 0x08},{":!\\!",1, 0x0A},{":!\\!",2, 0x0C},{":!\\!",3, 0x0E}, 
//   67   {":!^!", 0, 0x09},{":!^!", 1, 0x0B},{":!^!", 2, 0x0D},{":!^!", 3, 0x0F},
//   68   {"<TL",  0, 0x10},{"<TL",  1, 0x12},{"<TL",  2, 0x14},{"<TL",  3, 0x16},
//   69   {">TL",  0, 0x11},{">TL",  1, 0x13},{">TL",  2, 0x15},{">TL",  3, 0x17}, 
//   70   {"<TH",  0, 0x18},{"<TH",  1, 0x1A},{"<TH",  2, 0x1C},{"<TH",  3, 0x1E},   
//   71   {">TH",  0, 0x19},{">TH",  1, 0x1B},{">TH",  2, 0x1D},{">TH",  3, 0x1F}};  
//   72 
//   73 /*******************************************************************************
//   74  Set:  硬件控制设备设置
//   75 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function Set
        THUMB
//   76 u32 Set(u8 Object, u32 Value)
//   77 {
Set:
        LDR.N    R2,??Set_3       ;; 0x40011014
        LDR.N    R3,??Set_3+0x4   ;; 0x40011010
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+4
        CFI CFA R13+40
        STRB     R0,[SP, #+0]
        MOVS     R0,#+8
        MOV      R8,R0
        MOVS     R0,#+16
        MOV      R9,R0
        LDR.N    R0,??Set_3+0x8   ;; 0x40011810
        MOVS     R6,#+16384
        MOV      R11,R6
        LDRB     R6,[SP, #+0]
        MOVS     R4,R1
        LDR.N    R1,??Set_3+0xC   ;; 0x40011814
        LSRS     R5,R0,#+17
        MOV      R10,R5
        LDR.N    R5,??Set_3+0x10  ;; 0x40010c14
        CMP      R6,#+39
        BHI.W    ??Set_4
        TBH      [PC, R6, LSL #+1]
        DATA
??Set_0:
        DC16     +40,+57,+74,+77
        DC16     +82,+89,+96,+111
        DC16     +113,+137,+150,+144
        DC16     +233,+304,+321,+323
        DC16     +326,+339,+341,+356
        DC16     +359,+441,+441,+441
        DC16     +441,+441,+441,+441
        DC16     +441,+441,+441,+383
        DC16     +424,+424,+428,+441
        DC16     +424,+424,+424,+424
        THUMB
//   78   switch (Object){  
//   79   case CH_A_OFFSET:  if(Value < 65536){
??Set_5:
        LDR.N    R0,??Set_6       ;; 0x40000c34
        CMP      R4,#+65536
        BCS.N    ??Set_7
//   80                        TIM5_ARR = 470; TIM5_CCR1 = 450 - Value; // Value = 0~200
        LDR.N    R1,??Set_6+0x4   ;; 0x40000c2c
        MOVS     R2,#+470
        STR      R2,[R1, #+0]
        RSBS     R1,R4,#+450
??Set_8:
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   81                      } else {
//   82                        TIM5_ARR = Value >>16; TIM5_CCR1 = Value & 0xFFFF;
??Set_7:
        LDR.N    R1,??Set_6+0x4   ;; 0x40000c2c
        LSRS     R2,R4,#+16
        STR      R2,[R1, #+0]
        UXTH     R1,R4
        B.N      ??Set_8
//   83                      } break;
//   84   case CH_B_OFFSET:  if(Value < 65536){
??Set_9:
        LDR.N    R0,??Set_6+0x8   ;; 0x40000c38
        CMP      R4,#+65536
        BCS.N    ??Set_10
//   85                        TIM5_ARR = 470; TIM5_CCR2 = 450 - Value; // Value = 0~200
        LDR.N    R1,??Set_6+0x4   ;; 0x40000c2c
        MOVS     R2,#+470
        STR      R2,[R1, #+0]
        RSBS     R1,R4,#+450
??Set_11:
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   86                      } else {
//   87                        TIM5_ARR = Value >>16; TIM5_CCR2 = Value & 0xFFFF;
??Set_10:
        LDR.N    R1,??Set_6+0x4   ;; 0x40000c2c
        LSRS     R2,R4,#+16
        STR      R2,[R1, #+0]
        UXTH     R1,R4
        B.N      ??Set_8
//   88                      } break;
//   89   case BACKLIGHT:    TIM8_CCR1 = Value;                         // Value = 0~100
??Set_12:
        LDR.N    R0,??Set_6+0xC   ;; 0x40013434
??Set_13:
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//   90                      break;
//   91   case BEEP_VOLUME:  TIM8_CCR2 = 100 - Value/2;                 // Value = 0~50
??Set_14:
        LDR.N    R0,??Set_6+0x10  ;; 0x40013438
        MOVS     R1,#+100
        SUBS     R1,R1,R4, LSR #+1
        B.N      ??Set_8
//   92                      break;
//   93   case BETTERY_DT:   ADC3_CR2 |= (Value & 1)<<22;  // Value = 1/0   ADC3_CR2 |=0x00400000;
??Set_15:
        LDR.N    R0,??Set_6+0x14  ;; 0x40013c08
        MOVS     R2,#+1
        ANDS     R2,R2,R4
        LDR      R1,[R0, #+0]
        ORRS     R1,R1,R2, LSL #+22
        B.N      ??Set_11
//   94                      break;
//   95   case ADC_MODE:     if(Value == SEPARATE) FIFO_MODE_LOW();  
??Set_16:
        CMP      R4,#+0
        ITE     NE 
        STRNE    R8,[R3, #+0]
        STREQ    R8,[R2, #+0]
        B.N      ??Set_4
//   96                      else                  FIFO_MODE_HIGH();  break;
//   97   case FIFO_CLR:     if(Value == W_PTR){FIFO_CLRW_HIGH();  FIFO_CLRW_LOW();}
??Set_17:
        CMP      R4,#+1
        BNE.N    ??Set_18
        LDR.N    R1,??Set_6+0x18  ;; 0x40010c10
        MOVS     R0,#+2
        STR      R0,[R1, #+0]
        STR      R0,[R5, #+0]
        B.N      ??Set_4
//   98                      if(Value == R_PTR){FIFO_CLRR_HIGH();  FIFO_CLRR_LOW();} break;
??Set_18:
        CMP      R4,#+0
        BNE.W    ??Set_4
        STR      R9,[R3, #+0]
        STR      R9,[R2, #+0]
        B.N      ??Set_4
//   99   case T_BASE_PSC:   TIM1_PSC  = Value;
??Set_19:
        LDR.N    R0,??Set_6+0x1C  ;; 0x40012c28
        B.N      ??Set_13
//  100                      break;
//  101   case T_BASE_ARR:   if(Value==0)      {TIM1_CCER=0; RCC_CFGR=0x041D8402;} // MCO as SYSCLK  
??Set_20:
        LDR.N    R0,??Set_6+0x20  ;; 0x40012c20
        LDR.N    R1,??Set_6+0x24  ;; 0x40021004
        CBNZ     R4,??Set_21
        MOVS     R2,#+0
        STR      R2,[R0, #+0]
        LDR.N    R0,??Set_6+0x28  ;; 0x41d8402
??Set_22:
        STR      R0,[R1, #+0]
        B.N      ??Set_4
//  102                      else if(Value==1) {TIM1_CCER=0; RCC_CFGR=0x071D8402;} // MCO as SYSCLK/2 
??Set_21:
        CMP      R4,#+1
        BNE.N    ??Set_23
        MOVS     R2,#+0
        STR      R2,[R0, #+0]
        LDR.N    R0,??Set_6+0x2C  ;; 0x71d8402
        B.N      ??Set_22
//  103                      else  {RCC_CFGR=0x001D8402;  TIM1_CCER=0x0003;        // MCO as OC1 
??Set_23:
        LDR.N    R2,??Set_6+0x30  ;; 0x1d8402
        STR      R2,[R1, #+0]
        MOVS     R1,#+3
        STR      R1,[R0], #+12
//  104                             TIM1_ARR=Value;  TIM1_CCR1=(Value+1)/2;}
        STR      R4,[R0], #+8
        ADDS     R4,R4,#+1
        LSRS     R1,R4,#+1
        B.N      ??Set_8
//  105                      break;
//  106   case CH_A_COUPLE:  if(Value == AC ) AC_1();  else DC_1();
??Set_24:
        CMP      R4,#+1
        ITTEE   NE 
        MOVNE    R1,#+1
        STRNE    R1,[R0, #+0]
        MOVEQ    R0,#+1
        STREQ    R0,[R1, #+0]
        B.N      ??Set_4
//  107                      break;
//  108   case CH_B_COUPLE:  if(Value == AC ) AC_2();  else DC_2();
??Set_25:
        MOVS     R2,#+32
        CMP      R4,#+1
        ITE     NE 
        STRNE    R2,[R0, #+0]
        STREQ    R2,[R1, #+0]
        B.N      ??Set_4
//  109                      break;
//  110   case CH_A_RANGE:
//  111     switch (Value){  
??Set_26:
        MOVS     R2,#+4
        LSRS     R3,R0,#+21
        CMP      R4,#+8
        BHI.W    ??Set_4
        TBH      [PC, R4, LSL #+1]
        DATA
??Set_1:
        DC16     +9,+17,+25,+33
        DC16     +41,+48,+55,+62
        DC16     +69
        THUMB
//  112     case _50MV:  Ax0_ON();  Ax1_ON();  Ax2_HIGH(); Ax5_HIGH();
??Set_27:
        LDR.N    R1,??Set_6+0x18  ;; 0x40010c10
        STR      R9,[R0, #+0]
        STR      R3,[R1, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  113                  break;
//  114     case _100MV:  Ax0_ON();  Ax1_ON();  Ax2_LOW();  Ax5_HIGH();    
??Set_28:
        LDR.N    R4,??Set_6+0x18  ;; 0x40010c10
        STR      R9,[R0, #+0]
        STR      R3,[R4, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  115                  break;
//  116     case _200MV: Ax0_ON();  Ax1_ON();  Ax2_HIGH(); Ax5_LOW();
??Set_29:
        LDR.N    R4,??Set_6+0x18  ;; 0x40010c10
        STR      R9,[R0, #+0]
        STR      R3,[R4, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  117                  break;
//  118     case _500MV: Ax0_ON();  Ax1_ON();  Ax2_LOW();  Ax5_LOW(); 
??Set_30:
        STR      R9,[R0, #+0]
        LDR.N    R0,??Set_6+0x18  ;; 0x40010c10
        STR      R3,[R0, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  119                  break;
//  120     case _1V: Ax0_OFF(); Ax1_OFF(); Ax2_HIGH(); Ax5_HIGH(); 
??Set_31:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  121                  break;
//  122     case _2V:    Ax0_OFF(); Ax1_OFF(); Ax2_LOW();  Ax5_HIGH();
??Set_32:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  123                  break;
//  124     case _5V:    Ax0_OFF(); Ax1_OFF(); Ax2_HIGH(); Ax5_LOW(); 
??Set_33:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  125                  break;
//  126     case _10V:    Ax0_OFF(); Ax1_OFF(); Ax2_LOW();  Ax5_LOW();  
??Set_34:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  127                  break;
//  128     case CH_B:   Ax0_ON(); Ax1_OFF();  Ax2_LOW();  Ax5_LOW();
??Set_35:
        STR      R9,[R0, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  129                  break;
//  130     }  break;
//  131     
//  132   case CH_B_RANGE:
//  133     switch (Value){  
??Set_36:
        MOVS     R5,#+32768
        MOVS     R6,#+64
        CMP      R4,#+8
        BHI.W    ??Set_4
        TBB      [PC, R4]
        DATA
??Set_2:
        DC8      +5,+12,+18,+25
        DC8      +31,+37,+44,+50
        DC8      +57,+0
        THUMB
//  134     case _50MV:  Bx0_ON();  Bx1_ON();  Bx2_HIGH(); Bx5_HIGH();
??Set_37:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R3, #+0]
??Set_38:
        STR      R5,[R3, #+0]
        B.N      ??Set_4
//  135                  break;
//  136     case _100MV:  Bx0_ON();  Bx1_ON();  Bx2_LOW();  Bx5_HIGH();
??Set_39:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R2, #+0]
        B.N      ??Set_38
//  137                  break;
//  138     case _200MV: Bx0_ON();  Bx1_ON();  Bx2_HIGH();  Bx5_LOW();
??Set_40:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R3, #+0]
??Set_41:
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  139                  break;
//  140     case _500MV: Bx0_ON();  Bx1_ON();  Bx2_LOW();  Bx5_LOW();
??Set_42:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R2, #+0]
        B.N      ??Set_41
//  141                  break;
//  142     case _1V: Bx0_OFF(); Bx1_OFF(); Bx2_HIGH(); Bx5_HIGH();
??Set_43:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R3, #+0]
        B.N      ??Set_38
//  143                  break;
//  144     case _2V:    Bx0_OFF(); Bx1_OFF(); Bx2_LOW();  Bx5_HIGH();
??Set_44:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R3, #+0]
        B.N      ??Set_4
//  145                  break;
//  146     case _5V:    Bx0_OFF(); Bx1_OFF(); Bx2_HIGH();  Bx5_LOW();
??Set_45:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R3, #+0]
        B.N      ??Set_41
//  147                  break;
//  148     case _10V:    Bx0_OFF(); Bx1_OFF(); Bx2_LOW(); Bx5_LOW();
??Set_46:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  149                  break;
//  150     case CH_A:   Bx0_ON(); Bx1_OFF();  Bx2_LOW();  Bx5_LOW();
??Set_47:
        STR      R10,[R3, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R2, #+0]
        B.N      ??Set_41
//  151                  break;
//  152     }  break;
//  153     
//  154   case ANALOG_ARR:  GPIOB_CRL = 0x34BBB438;  TIM4_CR1 = 0x0080;  // SQR_OUT = Disnable  
??Set_48:
        LDR.N    R0,??Set_6+0x34  ;; 0x40010c00
        LDR.N    R1,??Set_6+0x38  ;; 0x34bbb438
        STR      R1,[R0, #+0]
        LDR.N    R0,??Set_6+0x3C  ;; 0x40000800
        MOVS     R1,#+128
        STR      R1,[R0, #+0]
//  155                     GPIOA_CRL   = 0x111011BB;  DAC_CR = 0x0001;  // DAC = Ensable 
        LDR.N    R0,??Set_6+0x40  ;; 0x40010800
        LDR.N    R1,??Set_6+0x44  ;; 0x111011bb
        STR      R1,[R0, #+0]
        LDR.N    R0,??Set_6+0x48  ;; 0x40007400
        MOVS     R1,#+1
        STR      R1,[R0, #+0]
//  156                     TIM7_ARR = Value;  TIM7_CR1 = 0x0085;  break;// DAC_CLK = Enable
        LDR.N    R0,??Set_6+0x4C  ;; 0x4000142c
        MOVS     R1,#+133
        STR      R4,[R0], #-44
        B.N      ??Set_8
//  157   case ANALOG_PTR:  DMA2_CMAR4  = Value;
??Set_49:
        LDR.N    R0,??Set_6+0x50  ;; 0x40020450
        B.N      ??Set_13
//  158                     break;
//  159   case ANALOG_CNT:  DMA2_CNDTR4 = Value;       // Fout = (Cnt*(ARR+1)/72)KHz
??Set_50:
        LDR.N    R0,??Set_6+0x54  ;; 0x40020448
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//  160                     break;
//  161   case DIGTAL_PSC:  TIM4_PSC = Value; GPIOA_CRL  |= 0x40000;  // DAC_OUT = Disnable
??Set_51:
        LDR.N    R0,??Set_6+0x58  ;; 0x40000828
        STR      R4,[R0, #+0]
        LDR.N    R0,??Set_6+0x40  ;; 0x40010800
        LDR      R1,[R0, #+0]
        ORRS     R1,R1,#0x40000
        STR      R1,[R0, #+0]
//  162                     TIM7_CR1 = 0x0084;  DAC_CR = 0;  break;   // DAC = Disnable
        LDR.N    R0,??Set_6+0x5C  ;; 0x40001400
        MOVS     R1,#+132
        STR      R1,[R0, #+0]
        LDR.N    R0,??Set_6+0x48  ;; 0x40007400
        MOVS     R1,#+0
        B.N      ??Set_8
//  163   case DIGTAL_ARR:  TIM4_ARR    = Value;
??Set_52:
        LDR.N    R0,??Set_6+0x60  ;; 0x4000082c
        B.N      ??Set_13
//  164                     break;
//  165   case DIGTAL_CCR:  GPIOB_CRL &= 0xF0FFFFFF;  GPIOB_CRL |= 0x0B000000; // PORT_SQR = Enable
??Set_53:
        LDR.N    R0,??Set_6+0x34  ;; 0x40010c00
        MVNS     R2,#+251658240
        LDR      R1,[R0, #+0]
        ANDS     R2,R2,R1
        STR      R2,[R0, #+0]
        LDR      R1,[R0, #+0]
        ORRS     R1,R1,#0xB000000
        STR      R1,[R0, #+0]
//  166                     TIM4_CCR1 = Value;  TIM4_CR1 = 0x0081; break;      // SQR_OUT = Enable 
        LDR.N    R0,??Set_6+0x64  ;; 0x40000834
        MOVS     R1,#+129
        STR      R4,[R0], #-52
        B.N      ??Set_8
//  167   case KEY_IF_RST:  TIM3_SR = 0;               //Clear TIM3 interrupt flag
??Set_54:
        LDR.N    R0,??Set_6+0x68  ;; 0x40000410
        MOVS     R1,#+0
        B.N      ??Set_11
//  168                     break;
//  169   case STANDBY:     if(Value == 1) { STB_EN();}  else { STB_DN();}   
??Set_55:
        LDR.N    R0,??Set_6+0x6C  ;; 0x40012c00
        CMP      R4,#+1
        BNE.N    ??Set_56
        LDR.N    R1,??Set_6+0x70  ;; 0x40011414
        STR      R10,[R1, #+0]
        MOVS     R1,#+132
        B.N      ??Set_8
??Set_56:
        LDR.N    R1,??Set_6+0x74  ;; 0x40011410
        STR      R10,[R1, #+0]
        MOVS     R1,#+133
        STR      R1,[R0, #+0]
        B.N      ??Set_4
        DATA
??Set_3:
        DC32     0x40011014
        DC32     0x40011010
        DC32     0x40011810
        DC32     0x40011814
        DC32     0x40010c14
        THUMB
//  170                     break;
//  171                     
//  172   case FPGA_RST:    GPIOB_CRH &= 0xF0FFFFFF;  GPIOB_CRH |= 0x01000000;        // 设PB14为输出状态
??Set_57:
        LDR.N    R4,??Set_6+0x78  ;; 0x40010c04
        MVNS     R1,#+251658240
        LDR      R0,[R4, #+0]
//  173                     SPI_CRST_LOW(); Delayms(1);   // SPI_CRST_LOW 1mS
//  174                     SPI_SS_HIGH(); Delayms(1);     // SPI_SS_HIGH  1mS
        LSRS     R6,R4,#+20
        ANDS     R1,R1,R0
        STR      R1,[R4, #+0]
        LDR      R0,[R4, #+0]
        ORRS     R0,R0,#0x1000000
        STR      R0,[R4, #+0]
        STR      R11,[R5, #+0]
        MOVS     R0,#+1
        _BLF     Delayms,??Delayms??rT
        LDR.N    R0,??Set_6+0x18  ;; 0x40010c10
        STR      R6,[R0, #+0]
        MOVS     R0,#+1
        _BLF     Delayms,??Delayms??rT
//  175                     SPI_SS_LOW(); Delayms(1);      // SPI_SS_LOW   1mS
        STR      R6,[R5, #+0]
        MOVS     R0,#+1
        _BLF     Delayms,??Delayms??rT
//  176                     SPI_CRST_HIGH(); Delayms(2);   // SPI_CRST_HIGH 2mS
        LDR.N    R0,??Set_6+0x18  ;; 0x40010c10
        STR      R11,[R0, #+0]
        MOVS     R0,#+2
        _BLF     Delayms,??Delayms??rT
//  177                     GPIOB_CRH &= 0xF0FFFFFF;  GPIOB_CRH |= 0x08000000; break; // 设PB14为输入状态 
        LDR      R0,[R4, #+0]
        MVNS     R1,#+251658240
        ANDS     R1,R1,R0
        STR      R1,[R4, #+0]
        LDR      R0,[R4, #+0]
        ORRS     R0,R0,#0x8000000
        STR      R0,[R4, #+0]
        B.N      ??Set_4
//  178 
//  179   case TRIGG_MODE:  Set_Param(Object, Value);             
??Set_58:
        LDRB     R0,[SP, #+0]
        UXTB     R1,R4
        B.N      ??Set_59
//  180                     break; 
//  181   case V_THRESHOLD: Set_Param(Object, Value);          
//  182                     break;    
//  183   case T_THRESHOLD: Set_Param(Object, Value & 0xFF);            
??Set_60:
        LDRB     R0,[SP, #+0]
        UXTB     R1,R4
        BL       Set_Param
//  184                     Set_Param(Object +1, Value >> 8);  break;
        LDRB     R0,[SP, #+0]
        LSRS     R1,R4,#+8
        UXTB     R1,R1
        ADDS     R0,R0,#+1
        UXTB     R0,R0
??Set_59:
        BL       Set_Param
//  185   case ADC_CTRL:    Set_Param(Object, Value);               
//  186                     break;
//  187   case A_POSITION:  Set_Param(Object, Value);              
//  188                     break; 
//  189   case B_POSITION:  Set_Param(Object, Value);              
//  190                     break; 
//  191   case REG_ADDR:    Set_Param(Object, Value);          
//  192                     break;    
//  193   }
//  194   return 0;
??Set_4:
        MOVS     R0,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Set_6:
        DC32     0x40000c34
        DC32     0x40000c2c
        DC32     0x40000c38
        DC32     0x40013434
        DC32     0x40013438
        DC32     0x40013c08
        DC32     0x40010c10
        DC32     0x40012c28
        DC32     0x40012c20
        DC32     0x40021004
        DC32     0x41d8402
        DC32     0x71d8402
        DC32     0x1d8402
        DC32     0x40010c00
        DC32     0x34bbb438
        DC32     0x40000800
        DC32     0x40010800
        DC32     0x111011bb
        DC32     0x40007400
        DC32     0x4000142c
        DC32     0x40020450
        DC32     0x40020448
        DC32     0x40000828
        DC32     0x40001400
        DC32     0x4000082c
        DC32     0x40000834
        DC32     0x40000410
        DC32     0x40012c00
        DC32     0x40011414
        DC32     0x40011410
        DC32     0x40010c04
        CFI EndBlock cfiBlock0
//  195 }
//  196 /*******************************************************************************
//  197  SendByte:  Send a byte to FPGA
//  198 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function SendByte
        THUMB
//  199 void SendByte(u8 Data) 
//  200 { 
//  201   u8 i;
//  202   
//  203   FIFO_SCK_HIGH();
SendByte:
        LDR.N    R1,??SendByte_0  ;; 0x40010810
//  204   for(i=0; i<8; ++i){
        LDR.N    R3,??SendByte_0+0x4  ;; 0x40010814
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        MOVS     R2,#+64
        STR      R2,[R1, #+0]
        MOVS     R5,#+0
        MOVS     R4,#+128
//  205     if((Data<<i) & 0x80) FIFO_SDA_HIGH();
??SendByte_1:
        MOVS     R6,R0
        LSLS     R6,R6,R5
        LSLS     R6,R6,#+24
        ITE     PL 
        STRPL    R4,[R3, #+0]
        STRMI    R4,[R1, #+0]
//  206     else                 FIFO_SDA_LOW();
//  207     FIFO_SCK_LOW();
        STR      R2,[R3, #+0]
//  208     FIFO_SCK_HIGH();
        STR      R2,[R1, #+0]
//  209   }  
        ADDS     R5,R5,#+1
        UXTB     R5,R5
        CMP      R5,#+8
        BCC.N    ??SendByte_1
//  210   FIFO_SDA_LOW();
        STR      R4,[R3, #+0]
//  211   FIFO_SCK_LOW();
        STR      R2,[R3, #+0]
//  212   FIFO_SDA_HIGH(); // Send data to buffer
        STR      R4,[R1, #+0]
//  213 }
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??SendByte_0:
        DC32     0x40010810
        DC32     0x40010814
        CFI EndBlock cfiBlock1
//  214 /*******************************************************************************
//  215  Set_Param: Trigger control Parameter Set 
//  216 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Set_Param
        THUMB
//  217 void Set_Param(u8 RegAddr, u8 Parameter) 
//  218 {
Set_Param:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  219   RegAddr &= 0x1F;
//  220   FIFO_H_L_HIGH();
//  221   SendByte(RegAddr);
        LSLS     R0,R0,#+27
        MOVS     R4,R1
        LDR.N    R1,??DataTable0  ;; 0x40011010
        MOVS     R5,#+32
        LSRS     R0,R0,#+27
        STR      R5,[R1, #+0]
        BL       SendByte
//  222   FIFO_H_L_LOW();
        LDR.N    R0,??DataTable2  ;; 0x40011014
        STR      R5,[R0, #+0]
//  223   SendByte(Parameter);
        MOVS     R0,R4
        POP      {R4,R5,LR}       ;; Pop
        CFI R4 SameValue
        CFI R5 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        B.N      SendByte
        CFI EndBlock cfiBlock2
//  224 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable0:
        DC32     0x40011010
//  225 /*******************************************************************************
//  226  Get: Get hardware attribute & status
//  227 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Get
        THUMB
//  228 u32 Get(u8 Object, u32 Value)
//  229 {
//  230   u16 Data;
//  231   u8* Ver;
//  232   
//  233   switch (Object){  
Get:
        LDR.N    R2,??Get_1       ;; 0x40010c08
        LDR.N    R3,??Get_1+0x4   ;; 0xffffffffffffeb30
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        LDR.N    R5,??Get_1+0x8   ;; HDW_Ver
        MOVS     R4,R1
        LDR.N    R1,??Get_1+0xC   ;; 0x40011408
        MOV      R8,R3
        LDR.N    R3,??DataTable2  ;; 0x40011014
        MOVS     R6,#+32
        CMP      R0,#+16
        BHI.W    ??Get_2
        TBB      [PC, R0]
        DATA
??Get_0:
        DC8      +9,+22,+14,+30
        DC8      +38,+87,+92,+99
        DC8      +101,+104,+106,+109
        DC8      +112,+138,+119,+154
        DC8      +165,+0
        THUMB
//  234     
//  235   case FIFO_DIGIT:  FIFO_H_L_LOW();  return (*(vu16 *)0x64000000); // 16bits FIFO Digital data
??Get_3:
        MOVS     R0,#+1677721600
        STR      R6,[R3, #+0]
        LDRH     R0,[R0, #+0]
        B.N      ??Get_4
//  236 
//  237   case FIFO_START:  FIFO_H_L_LOW();  return ((*(vu16 *)0x64000000)& 0x04)>> 2;    // Start = Bit2
??Get_5:
        MOVS     R0,#+1677721600
        STR      R6,[R3, #+0]
        LDRH     R0,[R0, #+0]
        MOVS     R1,#+4
        ANDS     R1,R1,R0
        ASRS     R0,R1,#+2
        B.N      ??Get_4
//  238 
//  239   case FIFO_EMPTY:  FIFO_H_L_LOW();  return ((*(vu16 *)0x64000000)& 0x10)>> 4;    // Empty = Bit4
??Get_6:
        MOVS     R0,#+1677721600
        STR      R6,[R3, #+0]
        LDRH     R0,[R0, #+0]
        MOVS     R1,#+16
        ANDS     R1,R1,R0
        ASRS     R0,R1,#+4
        B.N      ??Get_4
//  240 
//  241   case FIFO_FULL:   FIFO_H_L_LOW();  return ((*(vu16 *)0x64000000)& 0x08)>> 3;    // Full = Bit3
??Get_7:
        MOVS     R0,#+1677721600
        STR      R6,[R3, #+0]
        LDRH     R0,[R0, #+0]
        MOVS     R1,#+8
        ANDS     R1,R1,R0
        ASRS     R0,R1,#+3
        B.N      ??Get_4
//  242 
//  243   case KEY_STATUS:  Data  =(GPIOA_IDR & 0x4000);    Data |=(GPIOC_IDR & 0x0400)<<3; // K1, K2
??Get_8:
        LDR.N    R0,??Get_1+0x10  ;; 0x40010808
        LSLS     R3,R6,#+9
        LDR      R2,[R0, #+0]
        LSRS     R5,R0,#+20
        ANDS     R3,R3,R2
        LDR.N    R2,??Get_1+0x14  ;; 0x40011008
        LDR      R4,[R2, #+0]
        ANDS     R5,R5,R4
//  244                     Data |=(GPIOC_IDR & 0x0200)>>1; Data |=(GPIOC_IDR & 0x0100)<<1; // K3, K4
        LDR      R4,[R2, #+0]
        ORRS     R3,R3,R5, LSL #+3
        LSRS     R5,R0,#+21
        ANDS     R5,R5,R4
        LDR      R4,[R2, #+0]
        ORRS     R3,R3,R5, LSR #+1
        LSRS     R5,R0,#+22
        ANDS     R5,R5,R4
//  245                     Data |=(GPIOA_IDR & 0x2000)>>3; Data |=(GPIOC_IDR & 0x1000)>>1; // K5, K6
        LDR      R4,[R0, #+0]
        ORRS     R3,R3,R5, LSL #+1
        LSRS     R5,R0,#+17
        ANDS     R5,R5,R4
        LDR      R4,[R2, #+0]
//  246                     Data |=(GPIOC_IDR & 0x0800)<<1; Data |=(GPIOA_IDR & 0x8000);    // K7, K8
        LDR      R2,[R2, #+0]
        ORRS     R3,R3,R5, LSR #+3
        LSRS     R5,R0,#+18
        ANDS     R5,R5,R4
        LSRS     R4,R0,#+19
        ANDS     R4,R4,R2
        ORRS     R3,R3,R5, LSR #+1
        ORRS     R2,R3,R4, LSL #+1
        LDR      R3,[R0, #+0]
        LSLS     R0,R6,#+10
//  247                     Data |=(GPIOD_IDR & 0x0008);    Data |=(GPIOD_IDR & 0x0040);    // K9, K10
        MOVS     R5,#+64
        ANDS     R0,R0,R3
        LDR      R3,[R1, #+0]
        ORRS     R0,R0,R2
        MOVS     R2,#+8
        ANDS     R2,R2,R3
        ORRS     R2,R2,R0
        LDR      R0,[R1, #+0]
        ANDS     R5,R5,R0
        ORRS     R5,R5,R2
//  248                     return Data;                              // Current keys status
??Get_9:
        MOVS     R0,R5
        B.N      ??Get_4
//  249 
//  250   case USB_POWER:   return USB_PWR_ON;               // USB power on = 1   
??Get_10:
        LDR      R0,[R1, #+0]
        MOVS     R1,#+4
        ANDS     R1,R1,R0
        LSRS     R0,R1,#+2
        B.N      ??Get_4
//  251     
//  252   case V_BATTERY:   return (ADC3_DR*1400)/1024;      // Battery voltage (mV)  
??Get_11:
        LDR.N    R0,??Get_1+0x18  ;; 0x40013c4c
        MOVS     R1,#+1400
        LDR      R0,[R0, #+0]
        MULS     R0,R1,R0
        LSRS     R0,R0,#+10
        B.N      ??Get_4
//  253   
//  254   case VERTICAL:    return (u32)Y_ATTR;              // 垂直通道属性指针
??Get_12:
        ADDS     R5,R5,#+56
        B.N      ??Get_9
//  255     
//  256   case HORIZONTAL:  return (u32)X_ATTR;              // 水平通道属性指针
??Get_13:
        ADDS     R5,R5,#+236
        MOVS     R0,R5
        B.N      ??Get_4
//  257     
//  258   case GLOBAL:      return (u32)G_ATTR;              // 整体属性指针
??Get_14:
        ADDS     R5,R5,#+28
        B.N      ??Get_9
//  259   
//  260     
//  261   case TRIGGER:     return (u32)T_ATTR;              // 触发通道属性指针
??Get_15:
        ADDW     R0,R5,#+776
        B.N      ??Get_4
//  262     
//  263   case FPGA_OK:     return FPGA_CFG_OK;              // FPGA config ok = 1
??Get_16:
        LDR      R0,[R2, #+0]
        LSRS     R0,R0,#+15
        B.N      ??Get_4
//  264 
//  265   case CHARGE:      return CHRG_ST;                  // Battery charge = 1
??Get_17:
        LDR      R0,[R2, #+0]
        MOVS     R1,#+1
        LSRS     R0,R0,#+8
        ANDS     R1,R1,R0
        EORS     R0,R1,#0x1
        B.N      ??Get_4
//  266 
//  267   case DFUVER:      Ver = __Chk_DFU();               // DFU固件版本信息
??Get_18:
        _BLF     __Chk_DFU,??__Chk_DFU??rT
//  268                     if(Ver == 0)  Ver = (u8*)DFU_Ver;
        CBNZ     R0,??Get_19
        ADDS     R5,R5,#+20
        MOVS     R0,R5
//  269                     if(Value == 0) return (u32)Ver;
??Get_19:
        CMP      R4,#+0
        BEQ.N    ??Get_4
//  270                     else return (Ver[0]-'0')*100 +(Ver[2]-'0')*10 +(Ver[3]-'0'); 
        LDRB     R1,[R0, #+0]
        LDRB     R3,[R0, #+2]
        MOVS     R2,#+100
        LDRB     R0,[R0, #+3]
        MOVS     R4,#+10
        MULS     R3,R4,R3
        MLA      R1,R1,R2,R3
??Get_20:
        ADDS     R0,R1,R0
        MOV      R1,R8
        ADDS     R0,R0,R1
        B.N      ??Get_4
//  271   case HDWVER:      Ver = __Chk_HDW();               // 设备硬件版本信息
??Get_21:
        _BLF     __Chk_HDW,??__Chk_HDW??rT
//  272                     if(Ver == 0)  Ver = (u8*)(HDW_Ver + 13);
        CBNZ     R0,??Get_22
        ADDS     R5,R5,#+13
        MOVS     R0,R5
//  273                     if(Value == 0) return (u32)Ver;
??Get_22:
        CMP      R4,#+0
        BEQ.N    ??Get_4
//  274                     else return (Ver[0]-'0')*100 +(Ver[2]-'0')*10 +(Ver[3]-'0'); 
        LDRB     R1,[R0, #+0]
        LDRB     R3,[R0, #+2]
        MOVS     R2,#+100
        LDRB     R0,[R0, #+3]
        MOVS     R4,#+10
        MULS     R3,R4,R3
        MLA      R1,R1,R2,R3
        B.N      ??Get_20
//  275   case SYSVER:      Ver = (u8*)SYS_Ver;              // SYS程序模块版本信息
//  276                     if(Value == 0) return (u32)Ver;
??Get_23:
        LDR.N    R0,??Get_1+0x1C  ;; SYS_Ver
        CBZ      R4,??Get_4
//  277                     else return (Ver[0]-'0')*100 +(Ver[2]-'0')*10 +(Ver[3]-'0'); 
        LDRB     R1,[R0, #+0]
        LDRB     R3,[R0, #+2]
        MOVS     R2,#+100
        LDRB     R0,[R0, #+3]
        MOVS     R4,#+10
        MULS     R3,R4,R3
        MLA      R1,R1,R2,R3
        B.N      ??Get_20
//  278   case FPGAVER:     FIFO_H_L_LOW();  
??Get_24:
        STR      R6,[R3, #+0]
//  279                     Data = (*(vu16 *)0x64000000)>> 6; // FPGA配置程序版本信息
//  280                     u16ToDec5(VerStr, Data);
        LDR.N    R6,??Get_1+0x20  ;; VerStr
        MOVS     R0,#+1677721600
        LDRH     R0,[R0, #+0]
        LSRS     R5,R0,#+6
        MOVS     R1,R5
        MOVS     R0,R6
        _BLF     u16ToDec5,??u16ToDec5??rT
//  281                     VerStr[0]=VerStr[2]; VerStr[1]='.'; VerStr[2]=VerStr[3]; 
        LDRB     R0,[R6, #+2]
        STRB     R0,[R6, #+0]
        MOVS     R0,#+46
        STRB     R0,[R6, #+1]
        LDRB     R0,[R6, #+3]
        STRB     R0,[R6, #+2]
//  282                     VerStr[3]=VerStr[4]; VerStr[4]= 0; 
        LDRB     R0,[R6, #+4]
        STRB     R0,[R6, #+3]
        MOVS     R0,#+0
        STRB     R0,[R6, #+4]
//  283                     if(Value == 0) return (u32)(VerStr);
        CMP      R4,#+0
        ITE     NE 
        MOVNE    R0,R5
        MOVEQ    R0,R6
        B.N      ??Get_4
//  284                     else return Data; 
//  285   } 
//  286   return 0;                          // No used
??Get_2:
        MOVS     R0,#+0
??Get_4:
        POP      {R4-R8,PC}       ;; return
        DATA
??Get_1:
        DC32     0x40010c08
        DC32     0xffffffffffffeb30
        DC32     HDW_Ver
        DC32     0x40011408
        DC32     0x40010808
        DC32     0x40011008
        DC32     0x40013c4c
        DC32     SYS_Ver
        DC32     VerStr
        CFI EndBlock cfiBlock3
//  287 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable2:
        DC32     0x40011014

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??Delayms??rT:
        LDR.N    R3,??Subroutine0_0  ;; Delayms
        BX       R3
        DATA
??Subroutine0_0:
        DC32     Delayms
        CFI EndBlock cfiBlock4

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Chk_DFU??rT:
        LDR.N    R3,??Subroutine1_0  ;; __Chk_DFU
        BX       R3
        DATA
??Subroutine1_0:
        DC32     __Chk_DFU
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Chk_HDW??rT:
        LDR.N    R3,??Subroutine2_0  ;; __Chk_HDW
        BX       R3
        DATA
??Subroutine2_0:
        DC32     __Chk_HDW
        CFI EndBlock cfiBlock6

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI NoFunction
        THUMB
??u16ToDec5??rT:
        LDR.N    R3,??Subroutine3_0  ;; u16ToDec5
        BX       R3
        DATA
??Subroutine3_0:
        DC32     u16ToDec5
        CFI EndBlock cfiBlock7

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        END
//  288 /********************************* END OF FILE ********************************/
// 
// 1 646 bytes in segment CODE
// 1 096 bytes in segment DATA_C
//     9 bytes in segment DATA_Z
//    12 bytes in segment INITTAB
// 
// 1 614 bytes of CODE  memory (+ 44 bytes shared)
// 1 096 bytes of CONST memory
//     9 bytes of DATA  memory
//
//Errors: none
//Warnings: none
