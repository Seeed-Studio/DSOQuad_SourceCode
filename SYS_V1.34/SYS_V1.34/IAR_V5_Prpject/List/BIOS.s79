//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   30/Mar/2011  14:37:28 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\source\BIOS.c /
//    Command line    =  D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\source\BIOS.c /
//                        -lA D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\IAR_V4_P /
//                       rpject\List\ -o D:\Design\DS203_MiniDSO\SFW\SYS_V1. /
//                       32\IAR_V4_Prpject\Obj\ -s6 --no_unroll --no_inline  /
//                       --no_tbaa --no_scheduling --cpu_mode thumb          /
//                       --endian little --cpu cortex-M3 --stack_align 4 -e  /
//                       --fpu None --dlib_config "C:\Program Files\IAR      /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\LIB\dl7mptnnl8n.h" -I                /
//                       D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\IAR_V4_Prpjec /
//                       t\..\..\FWLib\inc\ -I D:\Design\DS203_MiniDSO\SFW\S /
//                       YS_V1.32\IAR_V4_Prpject\..\..\USBLib\inc\ -I        /
//                       D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\IAR_V4_Prpjec /
//                       t\..\include\ -I "C:\Program Files\IAR              /
//                       Systems\Embedded Workbench 4.0 Evaluation\arm\INC\" /
//    List file       =  D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\IAR_V4_Prpjec /
//                       t\List\BIOS.s79                                     /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME BIOS

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

??DataTable1 EQU 0
        MULTWEAK ??Delayms??rT
        PUBLIC G_ATTR
        PUBLIC Get
        FUNCTION Get,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC SendByte
        FUNCTION SendByte,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC Set
        FUNCTION Set,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC Set_Param
        FUNCTION Set_Param,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC T_ATTR
        PUBLIC X_ATTR
        PUBLIC Y_ATTR
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Delayms             SYMBOL "Delayms"
??Delayms??rT       SYMBOL "??rT", Delayms

        EXTERN Delayms
        FUNCTION Delayms,0202H

// D:\Design\DS203_MiniDSO\SFW\SYS_V1.32\source\BIOS.c
//    1 /********************* (C) COPYRIGHT 2010 e-Design Co.,Ltd. ********************
//    2  File Name : BIOS.c  
//    3  Version   : DS203_SYS Ver 1.3x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include "Config.h"
//    6 #include "Ident.h"
//    7 #include "BIOS.h"
//    8 #include "LCD.h"
//    9 #include "ASM.h"
//   10 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   11   const G_attr G_ATTR[1] =//LCD_X;LCD_Y;Yp_Max;Xp_Max;Tg_Num;Yv_Max;Xt_Max
G_ATTR:
        DATA
        DC16 400, 240, 7, 21, 15, 200, 4096, 1
        DC8 1, 1, 17, 0
        DC16 0, 1024, 0, 1024
//   12                          {  400,   240,   8-1,    22-1,   15,     200,    4096,  
//   13                           //Co_Max;Ya_Num;Yd_Num;INSERT;KpA1;KpA2;KpB1;KpB2
//   14                             1,     1,     1,     17,    0,   1024,  0, 1024};
//   15 
//   16   const Y_attr Y_ATTR[9] ={//  STR     KA1    KA2    KB1    KB2     SCALE 
Y_ATTR:
        DC8 "50mV"
        DC8 0, 0, 0
        DC16 0, 1024, 0, 1024
        DC32 2000
        DC8 "0.1V"
        DC8 0, 0, 0
        DC16 0, 1024, 0, 1024
        DC32 4000
        DC8 "0.2V"
        DC8 0, 0, 0
        DC16 -2, 1024, -6, 1024
        DC32 8000
        DC8 "0.5V"
        DC8 0, 0, 0
        DC16 -1, 1024, -6, 1024
        DC32 20000
        DC8 " 1V "
        DC8 0, 0, 0
        DC16 0, 1024, -6, 1024
        DC32 40000
        DC8 " 2V "
        DC8 0, 0, 0
        DC16 -2, 1024, -6, 1024
        DC32 80000
        DC8 " 5V "
        DC8 0, 0, 0
        DC16 -1, 1024, -6, 1024
        DC32 200000
        DC8 "!10V!"
        DC8 0, 0
        DC16 0, 1024, -6, 1024
        DC32 400000
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//   17                            { "50mV",    0,   1024,    0,   1024,    2000},
//   18                            { "0.1V",    0,   1024,    0,   1024,    4000},
//   19                            { "0.2V",   -2,   1024,   -6,   1024,    8000},
//   20                            { "0.5V",   -1,   1024,   -6,   1024,   20000},
//   21                            { " 1V ",    0,   1024,   -6,   1024,   40000},
//   22                            { " 2V ",   -2,   1024,   -6,   1024,   80000},
//   23                            { " 5V ",   -1,   1024,   -6,   1024,  200000},
//   24                            { "!10V!",   0,   1024,   -6,   1024,  400000}};
//   25   
//   26 const X_attr X_ATTR[27] ={
X_ATTR:
        DC8 "! 1S !"
        DC8 0
        DC16 999, 2399, 1200, 1024
        DC32 33333333
        DC8 "500mS"
        DC8 0, 0
        DC16 999, 1199, 600, 1024
        DC32 16666667
        DC8 "200mS"
        DC8 0, 0
        DC16 999, 479, 240, 1024
        DC32 6666667
        DC8 "100mS"
        DC8 0, 0
        DC16 999, 239, 120, 1024
        DC32 3333333
        DC8 "!50mS!"
        DC8 0
        DC16 999, 119, 60, 1024
        DC32 1666667
        DC8 "!20mS!"
        DC8 0
        DC16 99, 479, 240, 1024
        DC32 666667
        DC8 "!10mS!"
        DC8 0
        DC16 99, 239, 120, 1024
        DC32 333333
        DC8 " 5mS "
        DC8 0, 0
        DC16 99, 119, 60, 1024
        DC32 166667
        DC8 " 2mS "
        DC8 0, 0
        DC16 9, 479, 240, 1024
        DC32 66667
        DC8 " 1mS "
        DC8 0, 0
        DC16 9, 239, 120, 1024
        DC32 33333
        DC8 "500uS"
        DC8 0, 0
        DC16 9, 119, 60, 1024
        DC32 16667
        DC8 "200uS"
        DC8 0, 0
        DC16 0, 479, 240, 1024
        DC32 6667
        DC8 "100uS"
        DC8 0, 0
        DC16 0, 239, 120, 1024
        DC32 3333
        DC8 "!50uS!"
        DC8 0
        DC16 0, 119, 60, 1024
        DC32 1667
        DC8 "!20uS!"
        DC8 0
        DC16 0, 47, 24, 1024
        DC32 667
        DC8 "!10uS!"
        DC8 0
        DC16 0, 23, 12, 1024
        DC32 333
        DC8 " 5uS "
        DC8 0, 0
        DC16 0, 11, 6, 1024
        DC32 167
        DC8 " 2uS "
        DC8 0, 0
        DC16 0, 4, 3, 983
        DC32 67
        DC8 " 1uS "
        DC8 0, 0
        DC16 0, 2, 2, 819
        DC32 33
        DC8 "0.5uS"
        DC8 0, 0
        DC16 0, 1, 1, 614
        DC32 17
        DC8 "0.2uS"
        DC8 0, 0
        DC16 0, 0, 1, 492
        DC32 7
        DC8 "0.1uS"
        DC8 0, 0
        DC16 0, 0, 1, 246
        DC32 3
        DC8 " 2uS+"
        DC8 0, 0
        DC16 0, 9, 3, 983
        DC32 67
        DC8 " 1uS+"
        DC8 0, 0
        DC16 0, 4, 2, 983
        DC32 33
        DC8 ".5uS+"
        DC8 0, 0
        DC16 0, 2, 1, 819
        DC32 17
        DC8 ".2uS+"
        DC8 0, 0
        DC16 0, 1, 1, 983
        DC32 7
        DC8 ".1uS+"
        DC8 0, 0
        DC16 0, 0, 1, 491
        DC32 3
//   27 //   STR      PSC      ARR      CCR    KP     SCALE
//   28   {"! 1S !", 1000-1,  2400-1,  1200,  1024, 33333333},
//   29   {"500mS",  1000-1,  1200-1,   600,  1024, 16666667}, 
//   30   {"200mS",  1000-1,   480-1,   240,  1024,  6666667}, 
//   31   {"100mS",  1000-1,   240-1,   120,  1024,  3333333},
//   32   {"!50mS!", 1000-1,   120-1,    60,  1024,  1666667}, 
//   33   {"!20mS!",  100-1,   480-1,   240,  1024,   666667}, 
//   34   {"!10mS!",  100-1,   240-1,   120,  1024,   333333}, 
//   35   {" 5mS ",   100-1,   120-1,    60,  1024,   166667},
//   36   {" 2mS ",    10-1,   480-1,   240,  1024,    66667}, 
//   37   {" 1mS ",    10-1,   240-1,   120,  1024,    33333},   
//   38   {"500uS",    10-1,   120-1,    60,  1024,    16667}, 
//   39   {"200uS",     1-1,   480-1,   240,  1024,     6667},
//   40   {"100uS",     1-1,   240-1,   120,  1024,     3333}, 
//   41   {"!50uS!",    1-1,   120-1,    60,  1024,     1667}, 
//   42   {"!20uS!",    1-1,    48-1,    24,  1024,      667},      
//   43   {"!10uS!",    1-1,    24-1,    12,  1024,      333},      
//   44   {" 5uS ",     1-1,    12-1,     6,  1024,      167},       
//   45   {" 2uS ",     1-1,     5-1,     3,   983,       67}, //1024*4.8/5 =983
//   46   {" 1uS ",     1-1,     3-1,     2,   819,       33}, //1024*2.4/3 =819 
//   47   {"0.5uS",     1-1,     2-1,     1,   614,       17}, //1024*1.2/2 =614
//   48   {"0.2uS",     1-1,     1-1,     1,   492,        7}, //1024*0.48  =492
//   49   {"0.1uS",     1-1,     1-1,     1,   246,        3}, //1024*0.24  =246 
//   50   {" 2uS+",     1-1,    10-1,     3,   983,       67}, //1024*9.6/10=983
//   51   {" 1uS+",     1-1,     5-1,     2,   983,       33}, //1024*4.8/5 =983
//   52   {".5uS+",     1-1,     3-1,     1,   819,       17}, //1024*2.4/3 =819
//   53   {".2uS+",     1-1,     2-1,     1,   983,        7}, //1024*0.96  =983
//   54   {".1uS+",     1-1,     1-1,     1,   491,        3}};//1024*0.48  =492
//   55 
//   56 
//   57 const T_attr T_ATTR[32] ={
T_ATTR:
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 0, 0
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 1, 2
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 2, 4
        DC8 "<Vt"
        DC8 0, 0, 0, 0, 3, 6
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 0, 1
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 1, 3
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 2, 5
        DC8 ">Vt"
        DC8 0, 0, 0, 0, 3, 7
        DC8 ":!\\!"
        DC8 0, 0, 0, 0, 8
        DC8 ":!\\!"
        DC8 0, 0, 0, 1, 10
        DC8 ":!\\!"
        DC8 0, 0, 0, 2, 12
        DC8 ":!\\!"
        DC8 0, 0, 0, 3, 14
        DC8 ":!^!"
        DC8 0, 0, 0, 0, 9
        DC8 ":!^!"
        DC8 0, 0, 0, 1, 11
        DC8 ":!^!"
        DC8 0, 0, 0, 2, 13
        DC8 ":!^!"
        DC8 0, 0, 0, 3, 15
        DC8 "<TL"
        DC8 0, 0, 0, 0, 0, 16
        DC8 "<TL"
        DC8 0, 0, 0, 0, 1, 18
        DC8 "<TL"
        DC8 0, 0, 0, 0, 2, 20
        DC8 "<TL"
        DC8 0, 0, 0, 0, 3, 22
        DC8 ">TL"
        DC8 0, 0, 0, 0, 0, 17
        DC8 ">TL"
        DC8 0, 0, 0, 0, 1, 19
        DC8 ">TL"
        DC8 0, 0, 0, 0, 2, 21
        DC8 ">TL"
        DC8 0, 0, 0, 0, 3, 23
        DC8 "<TH"
        DC8 0, 0, 0, 0, 0, 24
        DC8 "<TH"
        DC8 0, 0, 0, 0, 1, 26
        DC8 "<TH"
        DC8 0, 0, 0, 0, 2, 28
        DC8 "<TH"
        DC8 0, 0, 0, 0, 3, 30
        DC8 ">TH"
        DC8 0, 0, 0, 0, 0, 25
        DC8 ">TH"
        DC8 0, 0, 0, 0, 1, 27
        DC8 ">TH"
        DC8 0, 0, 0, 0, 2, 29
        DC8 ">TH"
        DC8 0, 0, 0, 0, 3, 31
//   58 //  STR   CHx  CMD    STR   CHx  CMD    STR   CHx  CMD    STR   CHx  CMD
//   59   {"<Vt",  0, 0x00},{"<Vt",  1, 0x02},{"<Vt",  2, 0x04},{"<Vt",  3, 0x06},
//   60   {">Vt",  0, 0x01},{">Vt",  1, 0x03},{">Vt",  2, 0x05},{">Vt",  3, 0x07}, 
//   61   {":!\\!",0, 0x08},{":!\\!",1, 0x0A},{":!\\!",2, 0x0C},{":!\\!",3, 0x0E}, 
//   62   {":!^!", 0, 0x09},{":!^!", 1, 0x0B},{":!^!", 2, 0x0D},{":!^!", 3, 0x0F},
//   63   {"<TL",  0, 0x10},{"<TL",  1, 0x12},{"<TL",  2, 0x14},{"<TL",  3, 0x16},
//   64   {">TL",  0, 0x11},{">TL",  1, 0x13},{">TL",  2, 0x15},{">TL",  3, 0x17}, 
//   65   {"<TH",  0, 0x18},{"<TH",  1, 0x1A},{"<TH",  2, 0x1C},{"<TH",  3, 0x1E},   
//   66   {">TH",  0, 0x19},{">TH",  1, 0x1B},{">TH",  2, 0x1D},{">TH",  3, 0x1F}};  
//   67 
//   68 /*******************************************************************************
//   69  Set:  硬件控制设备设置
//   70 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function Set
        THUMB
//   71 u32 Set(u8 Object, u32 Value)
//   72 {
Set:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+4
        CFI CFA R13+40
        STRB     R0,[SP, #+0]
        MOVS     R4,R1
        MOVS     R0,#+8
        MOV      R8,R0
        MOVS     R0,#+16
        MOV      R9,R0
        LDR.N    R0,??Set_3       ;; 0x40011810
        LDR.N    R2,??Set_3+0x4   ;; 0x40011014
        LDR.N    R1,??Set_3+0x8   ;; 0x40011814
        LDR.N    R3,??Set_3+0xC   ;; 0x40011010
        LSRS     R5,R0,#+17
        MOV      R10,R5
        LDR.N    R5,??Set_3+0x10  ;; 0x40010c14
        MOVS     R6,#+16384
        MOV      R11,R6
        LDRB     R6,[SP, #+0]
        CMP      R6,#+39
        BHI.W    ??Set_4
        TBH      [PC, R6, LSL #+1]
        DATA
??Set_0:
        DC16     +40,+49,+58,+61
        DC16     +67,+75,+83,+97
        DC16     +100,+128,+143,+136
        DC16     +226,+302,+320,+323
        DC16     +326,+341,+344,+362
        DC16     +366,+454,+454,+454
        DC16     +454,+454,+454,+454
        DC16     +454,+454,+454,+391
        DC16     +432,+432,+439,+454
        DC16     +432,+432,+432,+432
        THUMB
//   73   switch (Object){  
//   74   case CH_A_OFFSET:  TIM5_ARR  = 470;  TIM5_CCR1 = 450 - Value; // Value = 0~200  
??Set_5:
        LDR.N    R0,??Set_6       ;; 0x40000c2c
        MOVS     R1,#+470
        STR      R1,[R0, #+0]
        ADDS     R0,R0,#+8
        RSBS     R1,R4,#+450
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   75                      break;
//   76   case CH_B_OFFSET:  TIM5_ARR  = 470;  TIM5_CCR2 = 450 - Value; // Value = 0~200
??Set_7:
        LDR.N    R0,??Set_6       ;; 0x40000c2c
        MOVS     R1,#+470
        STR      R1,[R0, #+0]
        ADDS     R0,R0,#+12
        RSBS     R1,R4,#+450
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   77                      break;
//   78   case BACKLIGHT:    TIM8_CCR1 = Value;                         // Value = 0~100
??Set_8:
        LDR.N    R0,??Set_6+0x4   ;; 0x40013434
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//   79                      break;
//   80   case BEEP_VOLUME:  TIM8_CCR2 = 100 - Value/2;                 // Value = 0~50
??Set_9:
        LDR.N    R0,??Set_6+0x8   ;; 0x40013438
        MOVS     R1,#+100
        SUBS     R1,R1,R4, LSR #+1
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   81                      break;
//   82   case BETTERY_DT:   ADC3_CR2 |= (Value & 1)<<22;  // Value = 1/0   ADC3_CR2 |=0x00400000;
??Set_10:
        LDR.N    R0,??Set_6+0xC   ;; 0x40013c08
        LDR      R1,[R0, #+0]
        MOVS     R2,#+1
        ANDS     R2,R2,R4
        ORRS     R1,R1,R2, LSL #+22
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   83                      break;
//   84   case ADC_MODE:     if(Value == SEPARATE) FIFO_MODE_LOW();  
??Set_11:
        CMP      R4,#+0
        BNE.N    ??Set_12
        STR      R8,[R2, #+0]
        B.N      ??Set_4
//   85                      else                  FIFO_MODE_HIGH();  break;
??Set_12:
        STR      R8,[R3, #+0]
        B.N      ??Set_4
//   86   case FIFO_CLR:     if(Value == W_PTR){FIFO_CLRW_HIGH();  FIFO_CLRW_LOW();}
??Set_13:
        CMP      R4,#+1
        BNE.N    ??Set_14
        MOVS     R0,#+2
        LDR.N    R1,??Set_6+0x10  ;; 0x40010c10
        STR      R0,[R1, #+0]
        STR      R0,[R5, #+0]
//   87                      if(Value == R_PTR){FIFO_CLRR_HIGH();  FIFO_CLRR_LOW();} break;
??Set_14:
        CMP      R4,#+0
        BNE.W    ??Set_4
        STR      R9,[R3, #+0]
        STR      R9,[R2, #+0]
        B.N      ??Set_4
//   88   case T_BASE_PSC:   TIM1_PSC  = Value;
??Set_15:
        LDR.N    R0,??Set_6+0x14  ;; 0x40012c28
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//   89                      break;
//   90   case T_BASE_ARR:   if(Value==0)      {TIM1_CCER=0; RCC_CFGR=0x041D8402;} // MCO as SYSCLK  
??Set_16:
        LDR.N    R0,??Set_6+0x18  ;; 0x40012c20
        LDR.N    R1,??Set_6+0x1C  ;; 0x40021004
        CMP      R4,#+0
        BNE.N    ??Set_17
        MOVS     R2,#+0
        STR      R2,[R0, #+0]
        LDR.N    R0,??Set_6+0x20  ;; 0x41d8402
        STR      R0,[R1, #+0]
        B.N      ??Set_4
//   91                      else if(Value==1) {TIM1_CCER=0; RCC_CFGR=0x071D8402;} // MCO as SYSCLK/2 
??Set_17:
        CMP      R4,#+1
        BNE.N    ??Set_18
        MOVS     R2,#+0
        STR      R2,[R0, #+0]
        LDR.N    R0,??Set_6+0x24  ;; 0x71d8402
        STR      R0,[R1, #+0]
        B.N      ??Set_4
//   92                      else  {RCC_CFGR=0x001D8402;  TIM1_CCER=0x0003;        // MCO as OC1 
??Set_18:
        LDR.N    R2,??Set_6+0x28  ;; 0x1d8402
        STR      R2,[R1, #+0]
        MOVS     R1,#+3
        STR      R1,[R0, #+0]
//   93                             TIM1_ARR=Value;  TIM1_CCR1=(Value+1)/2;}
        ADDS     R0,R0,#+12
        STR      R4,[R0, #+0]
        ADDS     R0,R0,#+8
        ADDS     R4,R4,#+1
        MOVS     R1,R4
        LSRS     R1,R1,#+1
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   94                      break;
//   95   case CH_A_COUPLE:  if(Value == AC ) AC_1();  else DC_1();
??Set_19:
        CMP      R4,#+1
        BNE.N    ??Set_20
        MOVS     R0,#+1
        STR      R0,[R1, #+0]
        B.N      ??Set_4
??Set_20:
        MOVS     R1,#+1
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//   96                      break;
//   97   case CH_B_COUPLE:  if(Value == AC ) AC_2();  else DC_2();
??Set_21:
        MOVS     R2,#+32
        CMP      R4,#+1
        BNE.N    ??Set_22
        STR      R2,[R1, #+0]
        B.N      ??Set_4
??Set_22:
        STR      R2,[R0, #+0]
        B.N      ??Set_4
//   98                      break;
//   99   case CH_A_RANGE:
//  100     switch (Value){  
??Set_23:
        MOVS     R2,#+4
        LSRS     R3,R0,#+21
        CMP      R4,#+8
        BHI.W    ??Set_4
        TBH      [PC, R4, LSL #+1]
        DATA
??Set_1:
        DC16     +9,+17,+25,+33
        DC16     +41,+48,+55,+62
        DC16     +69
        THUMB
//  101     case _50MV:  Ax0_ON();  Ax1_ON();  Ax2_HIGH(); Ax5_HIGH();
??Set_24:
        STR      R9,[R0, #+0]
        LDR.N    R1,??Set_6+0x10  ;; 0x40010c10
        STR      R3,[R1, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  102                  break;
//  103     case _100MV:  Ax0_ON();  Ax1_ON();  Ax2_LOW();  Ax5_HIGH();    
??Set_25:
        STR      R9,[R0, #+0]
        LDR.N    R4,??Set_6+0x10  ;; 0x40010c10
        STR      R3,[R4, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  104                  break;
//  105     case _200MV: Ax0_ON();  Ax1_ON();  Ax2_HIGH(); Ax5_LOW();
??Set_26:
        STR      R9,[R0, #+0]
        LDR.N    R4,??Set_6+0x10  ;; 0x40010c10
        STR      R3,[R4, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  106                  break;
//  107     case _500MV: Ax0_ON();  Ax1_ON();  Ax2_LOW();  Ax5_LOW(); 
??Set_27:
        STR      R9,[R0, #+0]
        LDR.N    R0,??Set_6+0x10  ;; 0x40010c10
        STR      R3,[R0, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  108                  break;
//  109     case _1V: Ax0_OFF(); Ax1_OFF(); Ax2_HIGH(); Ax5_HIGH(); 
??Set_28:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  110                  break;
//  111     case _2V:    Ax0_OFF(); Ax1_OFF(); Ax2_LOW();  Ax5_HIGH();
??Set_29:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R0, #+0]
        B.N      ??Set_4
//  112                  break;
//  113     case _5V:    Ax0_OFF(); Ax1_OFF(); Ax2_HIGH(); Ax5_LOW(); 
??Set_30:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R0, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  114                  break;
//  115     case _10V:    Ax0_OFF(); Ax1_OFF(); Ax2_LOW();  Ax5_LOW();  
??Set_31:
        STR      R9,[R1, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  116                  break;
//  117     case CH_B:   Ax0_ON(); Ax1_OFF();  Ax2_LOW();  Ax5_LOW();
??Set_32:
        STR      R9,[R0, #+0]
        STR      R3,[R5, #+0]
        STR      R2,[R1, #+0]
        STR      R8,[R1, #+0]
        B.N      ??Set_4
//  118                  break;
//  119     }  break;
//  120     
//  121   case CH_B_RANGE:
//  122     switch (Value){  
??Set_33:
        MOVS     R5,#+32768
        MOVS     R6,#+64
        CMP      R4,#+8
        BHI.W    ??Set_4
        TBB      [PC, R4]
        DATA
??Set_2:
        DC8      +5,+12,+19,+26
        DC8      +33,+40,+47,+54
        DC8      +61,+0
        THUMB
//  123     case _50MV:  Bx0_ON();  Bx1_ON();  Bx2_HIGH(); Bx5_HIGH();
??Set_34:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R3, #+0]
        STR      R5,[R3, #+0]
        B.N      ??Set_4
//  124                  break;
//  125     case _100MV:  Bx0_ON();  Bx1_ON();  Bx2_LOW();  Bx5_HIGH();
??Set_35:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R3, #+0]
        B.N      ??Set_4
//  126                  break;
//  127     case _200MV: Bx0_ON();  Bx1_ON();  Bx2_HIGH();  Bx5_LOW();
??Set_36:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R3, #+0]
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  128                  break;
//  129     case _500MV: Bx0_ON();  Bx1_ON();  Bx2_LOW();  Bx5_LOW();
??Set_37:
        STR      R10,[R3, #+0]
        STR      R6,[R0, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  130                  break;
//  131     case _1V: Bx0_OFF(); Bx1_OFF(); Bx2_HIGH(); Bx5_HIGH();
??Set_38:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R3, #+0]
        STR      R5,[R3, #+0]
        B.N      ??Set_4
//  132                  break;
//  133     case _2V:    Bx0_OFF(); Bx1_OFF(); Bx2_LOW();  Bx5_HIGH();
??Set_39:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R3, #+0]
        B.N      ??Set_4
//  134                  break;
//  135     case _5V:    Bx0_OFF(); Bx1_OFF(); Bx2_HIGH();  Bx5_LOW();
??Set_40:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R3, #+0]
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  136                  break;
//  137     case _10V:    Bx0_OFF(); Bx1_OFF(); Bx2_LOW(); Bx5_LOW();
??Set_41:
        STR      R10,[R2, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  138                  break;
//  139     case CH_A:   Bx0_ON(); Bx1_OFF();  Bx2_LOW();  Bx5_LOW();
??Set_42:
        STR      R10,[R3, #+0]
        STR      R6,[R1, #+0]
        STR      R11,[R2, #+0]
        STR      R5,[R2, #+0]
        B.N      ??Set_4
//  140                  break;
//  141     }  break;
//  142     
//  143   case ANALOG_ARR:  GPIOB_CRL = 0x34BBB438;  TIM4_CR1 = 0x0080;  // SQR_OUT = Disnable  
??Set_43:
        LDR.N    R0,??Set_6+0x2C  ;; 0x40010c00
        LDR.N    R1,??Set_6+0x30  ;; 0x34bbb438
        STR      R1,[R0, #+0]
        LDR.N    R0,??Set_6+0x34  ;; 0x40000800
        MOVS     R1,#+128
        STR      R1,[R0, #+0]
//  144                     GPIOA_CRL   = 0x111011BB;  DAC_CR = 0x0001;  // DAC = Ensable 
        LDR.N    R0,??Set_6+0x38  ;; 0x40010800
        LDR.N    R1,??Set_6+0x3C  ;; 0x111011bb
        STR      R1,[R0, #+0]
        LDR.N    R0,??Set_6+0x40  ;; 0x40007400
        MOVS     R1,#+1
        STR      R1,[R0, #+0]
//  145                     TIM7_ARR = Value;  TIM7_CR1 = 0x0085;  break;// DAC_CLK = Enable
        LDR.N    R0,??Set_6+0x44  ;; 0x4000142c
        STR      R4,[R0, #+0]
        SUBS     R0,R0,#+44
        MOVS     R1,#+133
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//  146   case ANALOG_PTR:  DMA2_CMAR4  = Value;
??Set_44:
        LDR.N    R0,??Set_6+0x48  ;; 0x40020450
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//  147                     break;
//  148   case ANALOG_CNT:  DMA2_CNDTR4 = Value;       // Fout = (Cnt*(ARR+1)/72)KHz
??Set_45:
        LDR.N    R0,??Set_6+0x4C  ;; 0x40020448
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//  149                     break;
//  150   case DIGTAL_PSC:  TIM4_PSC = Value; GPIOA_CRL  |= 0x40000;  // DAC_OUT = Disnable
??Set_46:
        LDR.N    R0,??Set_6+0x50  ;; 0x40000828
        STR      R4,[R0, #+0]
        LDR.N    R0,??Set_6+0x38  ;; 0x40010800
        MOV      R1,R0
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x40000
        STR      R1,[R0, #+0]
//  151                     TIM7_CR1 = 0x0084;  DAC_CR = 0;  break;   // DAC = Disnable
        LDR.N    R0,??Set_6+0x54  ;; 0x40001400
        MOVS     R1,#+132
        STR      R1,[R0, #+0]
        LDR.N    R0,??Set_6+0x40  ;; 0x40007400
        MOVS     R1,#+0
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//  152   case DIGTAL_ARR:  TIM4_ARR    = Value;
??Set_47:
        LDR.N    R0,??Set_6+0x58  ;; 0x4000082c
        STR      R4,[R0, #+0]
        B.N      ??Set_4
//  153                     break;
//  154   case DIGTAL_CCR:  GPIOB_CRL &= 0xF0FFFFFF;  GPIOB_CRL |= 0x0B000000; // PORT_SQR = Enable
??Set_48:
        LDR.N    R0,??Set_6+0x2C  ;; 0x40010c00
        MOV      R1,R0
        LDR      R1,[R1, #+0]
        MVNS     R2,#+251658240
        ANDS     R2,R2,R1
        STR      R2,[R0, #+0]
        MOV      R1,R0
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0xB000000
        STR      R1,[R0, #+0]
//  155                     TIM4_CCR1 = Value;  TIM4_CR1 = 0x0081; break;      // SQR_OUT = Enable 
        LDR.N    R0,??Set_6+0x5C  ;; 0x40000834
        STR      R4,[R0, #+0]
        SUBS     R0,R0,#+52
        MOVS     R1,#+129
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//  156   case KEY_IF_RST:  TIM3_SR = 0;               //Clear TIM3 interrupt flag
??Set_49:
        LDR.N    R0,??Set_6+0x60  ;; 0x40000410
        MOVS     R1,#+0
        STR      R1,[R0, #+0]
        B.N      ??Set_4
//  157                     break;
//  158   case STANDBY:     if(Value == 1) { STB_EN();}  else { STB_DN();}   
??Set_50:
        LDR.N    R0,??Set_6+0x64  ;; 0x40012c00
        CMP      R4,#+1
        BNE.N    ??Set_51
        LDR.N    R1,??Set_6+0x68  ;; 0x40011414
        STR      R10,[R1, #+0]
        MOVS     R1,#+132
        STR      R1,[R0, #+0]
        B.N      ??Set_4
??Set_51:
        LDR.N    R1,??Set_6+0x6C  ;; 0x40011410
        STR      R10,[R1, #+0]
        MOVS     R1,#+133
        STR      R1,[R0, #+0]
        B.N      ??Set_4
        DATA
??Set_3:
        DC32     0x40011810
        DC32     0x40011014
        DC32     0x40011814
        DC32     0x40011010
        DC32     0x40010c14
        THUMB
//  159                     break;
//  160                     
//  161   case FPGA_RST:    GPIOB_CRH &= 0xF0FFFFFF;  GPIOB_CRH |= 0x01000000;        // 设PB14为输出状态
??Set_52:
        LDR.N    R4,??Set_6+0x70  ;; 0x40010c04
        LDR      R0,[R4, #+0]
        MVNS     R1,#+251658240
        ANDS     R1,R1,R0
        STR      R1,[R4, #+0]
        LDR      R0,[R4, #+0]
        ORRS     R0,R0,#0x1000000
        STR      R0,[R4, #+0]
//  162                     SPI_CRST_LOW(); Delayms(1);   // SPI_CRST_LOW 1mS
        STR      R11,[R5, #+0]
        MOVS     R0,#+1
        _BLF     Delayms,??Delayms??rT
//  163                     SPI_SS_HIGH(); Delayms(1);     // SPI_SS_HIGH  1mS
        LSRS     R6,R4,#+20
        LDR.N    R0,??Set_6+0x10  ;; 0x40010c10
        STR      R6,[R0, #+0]
        MOVS     R0,#+1
        _BLF     Delayms,??Delayms??rT
//  164                     SPI_SS_LOW(); Delayms(1);      // SPI_SS_LOW   1mS
        STR      R6,[R5, #+0]
        MOVS     R0,#+1
        _BLF     Delayms,??Delayms??rT
//  165                     SPI_CRST_HIGH(); Delayms(2);   // SPI_CRST_HIGH 2mS
        LDR.N    R0,??Set_6+0x10  ;; 0x40010c10
        STR      R11,[R0, #+0]
        MOVS     R0,#+2
        _BLF     Delayms,??Delayms??rT
//  166                     GPIOB_CRH &= 0xF0FFFFFF;  GPIOB_CRH |= 0x08000000; break; // 设PB14为输入状态 
        LDR      R0,[R4, #+0]
        MVNS     R1,#+251658240
        ANDS     R1,R1,R0
        STR      R1,[R4, #+0]
        LDR      R0,[R4, #+0]
        ORRS     R0,R0,#0x8000000
        STR      R0,[R4, #+0]
        B.N      ??Set_4
//  167 
//  168   case TRIGG_MODE:  Set_Param(Object, Value);             
??Set_53:
        MOVS     R1,R4
        UXTB     R1,R1
        LDRB     R0,[SP, #+0]
        BL       Set_Param
        B.N      ??Set_4
//  169                     break; 
//  170   case V_THRESHOLD: Set_Param(Object, Value);          
//  171                     break;    
//  172   case T_THRESHOLD: Set_Param(Object, Value & 0xFF);            
??Set_54:
        MOVS     R1,R4
        UXTB     R1,R1
        LDRB     R0,[SP, #+0]
        BL       Set_Param
//  173                     Set_Param(Object +1, Value >> 8);  break;
        MOVS     R1,R4
        LSRS     R1,R1,#+8
        UXTB     R1,R1
        LDRB     R0,[SP, #+0]
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        BL       Set_Param
//  174   case ADC_CTRL:    Set_Param(Object, Value);               
//  175                     break;
//  176   case A_POSITION:  Set_Param(Object, Value);              
//  177                     break; 
//  178   case B_POSITION:  Set_Param(Object, Value);              
//  179                     break; 
//  180   case REG_ADDR:    Set_Param(Object, Value);          
//  181                     break;    
//  182   }
//  183   return 0;
??Set_4:
        MOVS     R0,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??Set_6:
        DC32     0x40000c2c
        DC32     0x40013434
        DC32     0x40013438
        DC32     0x40013c08
        DC32     0x40010c10
        DC32     0x40012c28
        DC32     0x40012c20
        DC32     0x40021004
        DC32     0x41d8402
        DC32     0x71d8402
        DC32     0x1d8402
        DC32     0x40010c00
        DC32     0x34bbb438
        DC32     0x40000800
        DC32     0x40010800
        DC32     0x111011bb
        DC32     0x40007400
        DC32     0x4000142c
        DC32     0x40020450
        DC32     0x40020448
        DC32     0x40000828
        DC32     0x40001400
        DC32     0x4000082c
        DC32     0x40000834
        DC32     0x40000410
        DC32     0x40012c00
        DC32     0x40011414
        DC32     0x40011410
        DC32     0x40010c04
        CFI EndBlock cfiBlock0
//  184 }
//  185 /*******************************************************************************
//  186  SendByte:  Send a byte to FPGA
//  187 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function SendByte
        THUMB
//  188 void SendByte(u8 Data) 
//  189 { 
SendByte:
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  190   u8 i;
//  191   
//  192   FIFO_SCK_HIGH();
        LDR.N    R1,??SendByte_0  ;; 0x40010810
        MOVS     R2,#+64
        STR      R2,[R1, #+0]
//  193   for(i=0; i<8; ++i){
        MOVS     R3,#+0
        LDR.N    R4,??SendByte_0+0x4  ;; 0x40010814
        MOVS     R5,#+128
        B.N      ??SendByte_1
//  194     if((Data<<i) & 0x80) FIFO_SDA_HIGH();
//  195     else                 FIFO_SDA_LOW();
??SendByte_2:
        STR      R5,[R4, #+0]
//  196     FIFO_SCK_LOW();
??SendByte_3:
        STR      R2,[R4, #+0]
//  197     FIFO_SCK_HIGH();
        STR      R2,[R1, #+0]
        ADDS     R3,R3,#+1
        UXTB     R3,R3
??SendByte_1:
        MOVS     R6,R3
        CMP      R6,#+8
        BCS.N    ??SendByte_4
        MOVS     R6,R0
        LSLS     R6,R6,R3
        LSLS     R6,R6,#+24
        BPL.N    ??SendByte_2
        STR      R5,[R1, #+0]
        B.N      ??SendByte_3
//  198   }  
//  199   FIFO_SDA_LOW();
??SendByte_4:
        STR      R5,[R4, #+0]
//  200   FIFO_SCK_LOW();
        STR      R2,[R4, #+0]
//  201   FIFO_SDA_HIGH(); // Send data to buffer
        STR      R5,[R1, #+0]
//  202 }
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??SendByte_0:
        DC32     0x40010810
        DC32     0x40010814
        CFI EndBlock cfiBlock1
//  203 /*******************************************************************************
//  204  Set_Param: Trigger control Parameter Set 
//  205 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Set_Param
        THUMB
//  206 void Set_Param(u8 RegAddr, u8 Parameter) 
//  207 {
Set_Param:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        MOVS     R4,R1
//  208   RegAddr &= 0x1F;
//  209   FIFO_H_L_HIGH();
        MOVS     R5,#+32
        LDR.N    R1,??DataTable0  ;; 0x40011010
        STR      R5,[R1, #+0]
//  210   SendByte(RegAddr);
        LSLS     R0,R0,#+27
        LSRS     R0,R0,#+27
        BL       SendByte
//  211   FIFO_H_L_LOW();
        LDR.N    R0,??DataTable2  ;; 0x40011014
        STR      R5,[R0, #+0]
//  212   SendByte(Parameter);
        MOVS     R0,R4
        BL       SendByte
//  213 }
        POP      {R4,R5,PC}       ;; return
        CFI EndBlock cfiBlock2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable0:
        DC32     0x40011010
//  214 /*******************************************************************************
//  215  Get: Get hardware attribute & status
//  216 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Get
        THUMB
//  217 u32 Get(u8 Object, u32 Value)
//  218 {
Get:
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        MOVS     R1,R0
//  219   u16 Data;
//  220   
//  221   switch (Object){  
        LDR.N    R3,??DataTable2  ;; 0x40011014
        MOVS     R4,#+32
        LDR.N    R2,??Get_1       ;; 0x40011408
        LDR.N    R0,??Get_1+0x4   ;; G_ATTR
        LDR.N    R5,??Get_1+0x8   ;; 0x40010c08
        CMP      R1,#+12
        BHI.W    ??Get_2
        TBB      [PC, R1]
        DATA
??Get_0:
        DC8      +7,+21,+12,+30
        DC8      +39,+88,+94,+101
        DC8      +103,+119,+105,+108
        DC8      +111,+0
        THUMB
//  222     
//  223   case FIFO_DIGIT:  FIFO_H_L_LOW();  return (*(vu16 *)0x64000000); // 16bits FIFO Digital data
??Get_3:
        STR      R4,[R3, #+0]
        MOVS     R0,#+1677721600
        LDRH     R0,[R0, #+0]
        B.N      ??Get_4
//  224 
//  225   case FIFO_START:  FIFO_H_L_LOW();  return ((*(vu16 *)0x64000000)& 0x04)>> 2;    // Start = Bit2
??Get_5:
        STR      R4,[R3, #+0]
        MOVS     R0,#+1677721600
        LDRH     R0,[R0, #+0]
        MOVS     R1,#+4
        ANDS     R1,R1,R0
        MOVS     R0,R1
        ASRS     R0,R0,#+2
        B.N      ??Get_4
//  226 
//  227   case FIFO_EMPTY:  FIFO_H_L_LOW();  return ((*(vu16 *)0x64000000)& 0x10)>> 4;    // Empty = Bit4
??Get_6:
        STR      R4,[R3, #+0]
        MOVS     R0,#+1677721600
        LDRH     R0,[R0, #+0]
        MOVS     R1,#+16
        ANDS     R1,R1,R0
        MOVS     R0,R1
        ASRS     R0,R0,#+4
        B.N      ??Get_4
//  228 
//  229   case FIFO_FULL:   FIFO_H_L_LOW();  return ((*(vu16 *)0x64000000)& 0x08)>> 3;    // Full = Bit3
??Get_7:
        STR      R4,[R3, #+0]
        MOVS     R0,#+1677721600
        LDRH     R0,[R0, #+0]
        MOVS     R1,#+8
        ANDS     R1,R1,R0
        MOVS     R0,R1
        ASRS     R0,R0,#+3
        B.N      ??Get_4
//  230 
//  231   case KEY_STATUS:  Data  =(GPIOA_IDR & 0x4000);    Data |=(GPIOC_IDR & 0x0400)<<3; // K1, K2
??Get_8:
        LDR.N    R0,??Get_1+0xC   ;; 0x40010808
        LDR      R1,[R0, #+0]
        LSLS     R3,R4,#+9
        ANDS     R3,R3,R1
        LDR.N    R1,??Get_1+0x10  ;; 0x40011008
        LDR      R4,[R1, #+0]
        LSRS     R5,R0,#+20
        ANDS     R5,R5,R4
        ORRS     R3,R3,R5, LSL #+3
//  232                     Data |=(GPIOC_IDR & 0x0200)>>1; Data |=(GPIOC_IDR & 0x0100)<<1; // K3, K4
        LDR      R4,[R1, #+0]
        LSRS     R5,R0,#+21
        ANDS     R5,R5,R4
        ORRS     R3,R3,R5, LSR #+1
        LDR      R4,[R1, #+0]
        LSRS     R5,R0,#+22
        ANDS     R5,R5,R4
        ORRS     R3,R3,R5, LSL #+1
//  233                     Data |=(GPIOA_IDR & 0x2000)>>3; Data |=(GPIOC_IDR & 0x1000)>>1; // K5, K6
        LDR      R4,[R0, #+0]
        LSRS     R5,R0,#+17
        ANDS     R5,R5,R4
        ORRS     R3,R3,R5, LSR #+3
        LDR      R4,[R1, #+0]
        LSRS     R5,R0,#+18
        ANDS     R5,R5,R4
        ORRS     R3,R3,R5, LSR #+1
//  234                     Data |=(GPIOC_IDR & 0x0800)<<1; Data |=(GPIOA_IDR & 0x8000);    // K7, K8
        LDR      R1,[R1, #+0]
        LSRS     R4,R0,#+19
        ANDS     R4,R4,R1
        ORRS     R1,R3,R4, LSL #+1
        LDR      R3,[R0, #+0]
        MOVS     R0,#+32768
        ANDS     R0,R0,R3
        ORRS     R0,R0,R1
//  235                     Data |=(GPIOD_IDR & 0x0008);    Data |=(GPIOD_IDR & 0x0040);    // K9, K10
        LDR      R3,[R2, #+0]
        MOVS     R1,#+8
        ANDS     R1,R1,R3
        ORRS     R1,R1,R0
        LDR      R2,[R2, #+0]
        MOVS     R0,#+64
        ANDS     R0,R0,R2
        ORRS     R0,R0,R1
//  236                     return Data;                              // Current keys status
        B.N      ??Get_4
//  237 
//  238   case USB_POWER:   return USB_PWR_ON;               // USB power on = 1   
??Get_9:
        LDR      R0,[R2, #+0]
        MOVS     R1,#+4
        ANDS     R1,R1,R0
        MOVS     R0,R1
        LSRS     R0,R0,#+2
        B.N      ??Get_4
//  239     
//  240   case V_BATTERY:   return (ADC3_DR*1400)/1024;      // Battery voltage (mV)  
??Get_10:
        LDR.N    R0,??Get_1+0x14  ;; 0x40013c4c
        LDR      R0,[R0, #+0]
        MOVS     R1,#+1400
        MULS     R0,R1,R0
        LSRS     R0,R0,#+10
        B.N      ??Get_4
//  241   
//  242   case VERTICAL:    return (u32)Y_ATTR;              // 垂直通道属性指针
??Get_11:
        ADDS     R0,R0,#+28
        B.N      ??Get_4
//  243     
//  244   case HORIZONTAL:  return (u32)X_ATTR;              // 水平通道属性指针
??Get_12:
        ADDS     R0,R0,#+208
        B.N      ??Get_4
//  245     
//  246   case GLOBAL:      return (u32)G_ATTR;              // 整体属性指针
//  247   
//  248     
//  249   case TRIGGER:     return (u32)T_ATTR;              // 触发通道属性指针
??Get_13:
        ADDW     R0,R0,#+748
        B.N      ??Get_4
//  250     
//  251   case FPGA_OK:     return FPGA_CFG_OK;              // FPGA config ok = 1
??Get_14:
        LDR      R0,[R5, #+0]
        LSRS     R0,R0,#+15
        B.N      ??Get_4
//  252 
//  253   case CHARGE:      return CHRG_ST;                  // Battery charge = 1
??Get_15:
        LDR      R0,[R5, #+0]
        LSRS     R0,R0,#+8
        MOVS     R1,#+1
        ANDS     R1,R1,R0
        EORS     R0,R1,#0x1
        B.N      ??Get_4
//  254 
//  255   }
//  256   return 0;                          // No used
??Get_2:
        MOVS     R0,#+0
??Get_4:
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??Get_1:
        DC32     0x40011408
        DC32     G_ATTR
        DC32     0x40010c08
        DC32     0x40010808
        DC32     0x40011008
        DC32     0x40013c4c
        CFI EndBlock cfiBlock3
//  257 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable2:
        DC32     0x40011014

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??Delayms??rT:
        LDR.N    R3,??Subroutine0_0  ;; Delayms
        BX       R3
        DATA
??Subroutine0_0:
        DC32     Delayms
        CFI EndBlock cfiBlock4

        END
//  258 /********************************* END OF FILE ********************************/
// 
// 1 490 bytes in segment CODE
// 1 068 bytes in segment DATA_C
// 
// 1 482 bytes of CODE  memory (+ 8 bytes shared)
// 1 068 bytes of CONST memory
//
//Errors: none
//Warnings: none
